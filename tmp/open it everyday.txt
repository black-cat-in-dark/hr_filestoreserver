.lib 文件包含DLL导出的函数和变量的符号名，只是用来为链接程序提供必要的信息，以便在链接时找到函数或变量的入口地址；.dll 文件才包含实际的函数和数据。所以首先需要将 dllDemo.lib 引入到当前项目。


在 main.c 中除了用 extern 关键字声明 add() 和 sub() 函数来自外部文件，还可以用 _declspec(dllimport) 标识符声明函数来自动态链接库。

为了更好的进行模块化设计，最好将 add() 和 sub() 函数的声明放在头文件中，

accept() 返回一个新的套接字来和客户端通信，addr 保存了客户端的IP地址和端口号，而 sock 是服务器端的套接字，大家注意区分。


server与client一共用到了三个socket，可以有两种理解：
1 server与client的两个_sock都代表服务器的socket，connect就是把两端的socket连上，但这样的问题就是cSock竟然是在server中（通过accept）生成。 recv的socket是从哪里来的，send的socket是发送给谁。
2 server用到_sock与cSock，client用到_sock，其中_sock都代表自己的端，特殊在于server的recv都用一个_sock，而send却各有各的cSock，另一边在client中recv与send都用_sock。


这是因为当你把一对小括号放在后面，这个函数就会执行；然而如果你不放括号在它后面，那它可以被到处传递，并且可以赋值给别的变量而不去执行它。 

1、不带括号时，调用的是这个函数本身 ，是整个函数体，是一个函数对象，不需等该函数执行完成
2、带括号（此时必须传入需要的参数），调用的是函数的return结果，需要等待函数执行完成的结果

显然，被“＠函数”修饰的函数不再是原来的函数，而是被替换成一个新的东西（取决于装饰器的返回值），即如果装饰器函数的返回值为普通变量，那么被修饰的函数名就变成了变量名；同样，如果装饰器返回的是一个函数的名称，怎么被修饰的函数名依然表示一个函数。


在服务器中，0.0.0.0表示本机上所有的IP地址，如果本机一个服务监听的地址为（host)0.0.0.0，那么其它机器访问这个服务器上的任何一个IP都可以调用这个服务
在路由中，0.0.0.0代表默认路由

web服务（ngnix,apache)监听的是80端口，后端服务（python flask）等提供服务响应

文件（file）是一种无区别的叫法，如何运行和处理这个文件，决定了它的性质。直接从这个文件运行，那么这个文件就叫做脚本。导入这个文件，那么这个文件就是模块（module）。另外，一个包（package）是一个包含有__init__.py的文件夹，